<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: apache | chapter31 &raquo;]]></title>
  <link href="http://chapter31.com/categories/apache/atom.xml" rel="self"/>
  <link href="http://chapter31.com/"/>
  <updated>2013-06-25T12:45:09+10:00</updated>
  <id>http://chapter31.com/</id>
  <author>
    <name><![CDATA[Michael Sharman]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[PHP ['SCRIPT_NAME'] returning empty string]]></title>
    <link href="http://chapter31.com/2013/06/21/php-script-name-returning-empty-string/"/>
    <updated>2013-06-21T11:58:00+10:00</updated>
    <id>http://chapter31.com/2013/06/21/php-script-name-returning-empty-string</id>
    <content type="html"><![CDATA[<p>I was working with <a href="http://slimframework.com/">Slim</a> (v2.2.x) the other day and saw that a PHP warning was being thrown in one of the interal Slim files:</p>

<p><code>bash
Warning: strpos(): Empty needle in /vendor/slim/slim/Slim/Environment.php on line 143
</code></p>

<p>The code throwing the warning was the following <em>if</em> statement:</p>

<p><code>php
if (strpos($_SERVER['REQUEST_URI'], $_SERVER['SCRIPT_NAME']) === 0) {
</code></p>

<p>The actual issue was that <code>$_SERVER['SCRIPT_NAME']</code> was an empty string, so <em>strpos</em> was complaining as that is invalid syntax. Strangely, this was all working fine when we had the apache rewrite rules in an .htaccess file:</p>

<p><code>bash
RewriteCond %{DOCUMENT_ROOT}%{REQUEST_URI} !-f
RewriteRule ^(.*)$ /index.php/$1 [QSA,L]
</code></p>

<p>However once we moved the rules to the <em>VirtualHost</em> we got the warning. Some <a href="https://issues.apache.org/bugzilla/show_bug.cgi?id=40102">googling</a> <a href="https://bugs.php.net/bug.php?id=38141">told me</a> that this is a 6 year old problem with either apache, php, mod_php or the boogey man...depending on who you believe. It seems that various rewrite settings working differently if you have them in .htaccess vs the VirtualHost block.</p>

<p>I considered sending a pull request to Slim to handle the scenario where SCRIPT_NAME is empty:</p>

<p><code>php
if (strlen($_SERVER['SCRIPT_NAME']) &amp;&amp; strpos($_SERVER['REQUEST_URI'], $_SERVER['SCRIPT_NAME']) === 0) {
</code></p>

<p>But instead we added the PT (passthrough) rewrite flag. This works fine for what we're doing and <code>$_SERVER['SCRIPT_NAME']</code> now returns <em>/index.php</em> as it should.</p>

<p><code>bash
RewriteCond %{DOCUMENT_ROOT}%{REQUEST_URI} !-f
RewriteRule ^(.*)$ /index.php/$1 [QSA,PT,L]
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 6 caching POST requests]]></title>
    <link href="http://chapter31.com/2013/05/09/ios-6-caching-post-requests/"/>
    <updated>2013-05-09T14:28:00+10:00</updated>
    <id>http://chapter31.com/2013/05/09/ios-6-caching-post-requests</id>
    <content type="html"><![CDATA[<p>Apparently I've been living under a rock, never having been bitten (that I know of) by the pretty massive bug Apple rolled out in iOS 6 (with Safari). The bug has been well documented around the interwebs, basically Safari caches HTTP POST requests. If you haven't heard about this...stop and read that last bit again.</p>

<p>Now, replicating this bug is dependent on the payload of the POST not changing between requests, so in many circumstances you may be fine. However let's talk about something like a simple login form.</p>

<ul>
<li>User enters credentials in web form and clicks "Login"</li>
<li>App/site POSTs data to the server for authentication</li>
<li>Server authenticates request</li>
<li>200 OK is returned, and a session is spawned on the server</li>
</ul>


<p>Pretty standard workflow. Now what happens if the session expires and the user is presented with the login form again?</p>

<ul>
<li>User enters credentials in web form and clicks "Login"</li>
<li>App/site POSTs data to the server for authentication</li>
<li>The request is cached because the users data (credentials) are the same as before</li>
</ul>


<p>So in this scenario the request never actually gets sent to the server.  Your app/site is now broken, the user cannot login. This sort of issue can of course have huge consequences for any number of websites/applications.</p>

<p>It's worth noting that the <a href="http://www.faqs.org/rfcs/rfc2616.html">HTTP/1.1 RFC</a> states (thanks <a href="http://stackoverflow.com/a/626083/1448058">Diomidis Spinellis</a>):</p>

<blockquote><p>Responses to this method are not cacheable, unless the response includes appropriate Cache-Control or Expires header fields.</p></blockquote>

<p>and:</p>

<blockquote><p>Some HTTP methods MUST cause a cache to invalidate an entity. This is either the entity referred to by the Request-URI, or by the Location or Content-Location headers (if present). These methods are:</p>

<ul>
<li>PUT</li>
<li>DELETE</li>
<li>POST</li>
</ul>
</blockquote>

<h2>Solution</h2>

<p>People have listed fixes like jQuery's <em>{cache: false}</em> in the ajax params, to adding a random token to your payload. These methods seem a intrusive to me though as you need to change every form on every page in every app. So we went for a different approach, a simple Apache rule in your conf:</p>

<p>```bash
<Limit POST></p>

<pre><code>Header set Cache-Control no-cache
</code></pre>

<p></Limit>
```</p>

<p>All that's saying is, if the incoming request is using the HTTP POST method, set a <em>no-cache</em> header. Nice and simple. Note that <em>mod_headers</em> needs to be enabled in Apache for this to work.</p>
]]></content>
  </entry>
  
</feed>
